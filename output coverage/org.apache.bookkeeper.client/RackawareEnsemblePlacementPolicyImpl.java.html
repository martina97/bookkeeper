<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RackawareEnsemblePlacementPolicyImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bookkeeper$Bokkeeper2Test.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">RackawareEnsemblePlacementPolicyImpl.java</span></div><h1>RackawareEnsemblePlacementPolicyImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.client;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIES_JOINED;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIES_LEFT;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNTER;
import static org.apache.bookkeeper.client.BookKeeperClientStats.CLIENT_SCOPE;
import static org.apache.bookkeeper.client.BookKeeperClientStats.NUM_WRITABLE_BOOKIES_IN_DEFAULT_RACK;
import static org.apache.bookkeeper.client.BookKeeperClientStats.READ_REQUESTS_REORDERED;
import static org.apache.bookkeeper.client.RegionAwareEnsemblePlacementPolicy.UNKNOWN_REGION;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;

import io.netty.util.HashedWheelTimer;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import java.util.concurrent.locks.ReentrantReadWriteLock;
import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;
import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;
import org.apache.bookkeeper.client.WeightedRandomSelection.WeightedObject;
import org.apache.bookkeeper.common.util.ReflectionUtils;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.conf.Configurable;
import org.apache.bookkeeper.feature.FeatureProvider;
import org.apache.bookkeeper.net.BookieNode;
import org.apache.bookkeeper.net.BookieSocketAddress;
import org.apache.bookkeeper.net.DNSToSwitchMapping;
import org.apache.bookkeeper.net.NetworkTopology;
import org.apache.bookkeeper.net.NetworkTopologyImpl;
import org.apache.bookkeeper.net.Node;
import org.apache.bookkeeper.net.NodeBase;
import org.apache.bookkeeper.net.ScriptBasedMapping;
import org.apache.bookkeeper.net.StabilizeNetworkTopology;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.Gauge;
import org.apache.bookkeeper.stats.OpStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.stats.annotations.StatsDoc;
import org.apache.commons.collections4.CollectionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Simple rackware ensemble placement policy.
 *
 * &lt;p&gt;Make most of the class and methods as protected, so it could be extended to implement other algorithms.
 */
@StatsDoc(
    name = CLIENT_SCOPE,
    help = &quot;BookKeeper client stats&quot;
)
public class RackawareEnsemblePlacementPolicyImpl extends TopologyAwareEnsemblePlacementPolicy {

<span class="fc" id="L85">    static final Logger LOG = LoggerFactory.getLogger(RackawareEnsemblePlacementPolicyImpl.class);</span>
    int maxWeightMultiple;

    protected int minNumRacksPerWriteQuorum;
    protected boolean enforceMinNumRacksPerWriteQuorum;
    protected boolean ignoreLocalNodeInPlacementPolicy;

    public static final String REPP_DNS_RESOLVER_CLASS = &quot;reppDnsResolverClass&quot;;
    public static final String REPP_RANDOM_READ_REORDERING = &quot;ensembleRandomReadReordering&quot;;

    static final int RACKNAME_DISTANCE_FROM_LEAVES = 1;

    // masks for reordering
    static final int LOCAL_MASK       = 0x01 &lt;&lt; 24;
    static final int LOCAL_FAIL_MASK  = 0x02 &lt;&lt; 24;
    static final int REMOTE_MASK      = 0x04 &lt;&lt; 24;
    static final int REMOTE_FAIL_MASK = 0x08 &lt;&lt; 24;
    static final int READ_ONLY_MASK   = 0x10 &lt;&lt; 24;
    static final int SLOW_MASK        = 0x20 &lt;&lt; 24;
    static final int UNAVAIL_MASK     = 0x40 &lt;&lt; 24;
    static final int MASK_BITS        = 0xFFF &lt;&lt; 20;

    protected HashedWheelTimer timer;
    // Use a loading cache so slow bookies are expired. Use entryId as values.
    protected Cache&lt;BookieSocketAddress, Long&gt; slowBookies;
    protected BookieNode localNode;
<span class="fc" id="L111">    protected boolean reorderReadsRandom = false;</span>
<span class="fc" id="L112">    protected boolean enforceDurability = false;</span>
<span class="fc" id="L113">    protected int stabilizePeriodSeconds = 0;</span>
<span class="fc" id="L114">    protected int reorderThresholdPendingRequests = 0;</span>
    // looks like these only assigned in the same thread as constructor, immediately after constructor;
    // no need to make volatile
<span class="fc" id="L117">    protected StatsLogger statsLogger = null;</span>

<span class="fc" id="L119">    @StatsDoc(</span>
            name = READ_REQUESTS_REORDERED,
            help = &quot;The distribution of number of bookies reordered on each read request&quot;
    )
    protected OpStatsLogger readReorderedCounter = null;
<span class="fc" id="L124">    @StatsDoc(</span>
            name = FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNTER,
            help = &quot;Counter for number of times DNSResolverDecorator failed to resolve Network Location&quot;
    )
    protected Counter failedToResolveNetworkLocationCounter = null;
    @StatsDoc(
            name = NUM_WRITABLE_BOOKIES_IN_DEFAULT_RACK,
            help = &quot;Gauge for the number of writable Bookies in default rack&quot;
    )
    protected Gauge&lt;Integer&gt; numWritableBookiesInDefaultRack;

<span class="fc" id="L135">    private String defaultRack = NetworkTopology.DEFAULT_RACK;</span>

    RackawareEnsemblePlacementPolicyImpl() {
<span class="fc" id="L138">        this(false);</span>
<span class="fc" id="L139">    }</span>

<span class="fc" id="L141">    RackawareEnsemblePlacementPolicyImpl(boolean enforceDurability) {</span>
<span class="fc" id="L142">        this.enforceDurability = enforceDurability;</span>
<span class="fc" id="L143">        topology = new NetworkTopologyImpl();</span>
<span class="fc" id="L144">    }</span>

    /**
     * Initialize the policy.
     *
     * @param dnsResolver the object used to resolve addresses to their network address
     * @return initialized ensemble placement policy
     */
    protected RackawareEnsemblePlacementPolicyImpl initialize(DNSToSwitchMapping dnsResolver,
                                                              HashedWheelTimer timer,
                                                              boolean reorderReadsRandom,
                                                              int stabilizePeriodSeconds,
                                                              int reorderThresholdPendingRequests,
                                                              boolean isWeighted,
                                                              int maxWeightMultiple,
                                                              int minNumRacksPerWriteQuorum,
                                                              boolean enforceMinNumRacksPerWriteQuorum,
                                                              boolean ignoreLocalNodeInPlacementPolicy,
                                                              StatsLogger statsLogger) {
<span class="fc" id="L163">        checkNotNull(statsLogger, &quot;statsLogger should not be null, use NullStatsLogger instead.&quot;);</span>
<span class="fc" id="L164">        this.statsLogger = statsLogger;</span>
<span class="fc" id="L165">        this.bookiesJoinedCounter = statsLogger.getOpStatsLogger(BOOKIES_JOINED);</span>
<span class="fc" id="L166">        this.bookiesLeftCounter = statsLogger.getOpStatsLogger(BOOKIES_LEFT);</span>
<span class="fc" id="L167">        this.readReorderedCounter = statsLogger.getOpStatsLogger(READ_REQUESTS_REORDERED);</span>
<span class="fc" id="L168">        this.failedToResolveNetworkLocationCounter = statsLogger.getCounter(FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNTER);</span>
<span class="fc" id="L169">        this.numWritableBookiesInDefaultRack = new Gauge&lt;Integer&gt;() {</span>
            @Override
            public Integer getDefaultValue() {
<span class="nc" id="L172">                return 0;</span>
            }

            @Override
            public Integer getSample() {
<span class="nc" id="L177">                rwLock.readLock().lock();</span>
                try {
<span class="nc" id="L179">                    return topology.countNumOfAvailableNodes(getDefaultRack(), Collections.emptySet());</span>
                } finally {
<span class="nc" id="L181">                    rwLock.readLock().unlock();</span>
                }
            }
        };
<span class="fc" id="L185">        this.statsLogger.registerGauge(NUM_WRITABLE_BOOKIES_IN_DEFAULT_RACK, numWritableBookiesInDefaultRack);</span>
<span class="fc" id="L186">        this.reorderReadsRandom = reorderReadsRandom;</span>
<span class="fc" id="L187">        this.stabilizePeriodSeconds = stabilizePeriodSeconds;</span>
<span class="fc" id="L188">        this.reorderThresholdPendingRequests = reorderThresholdPendingRequests;</span>
<span class="fc" id="L189">        this.dnsResolver = new DNSResolverDecorator(dnsResolver, () -&gt; this.getDefaultRack(),</span>
                failedToResolveNetworkLocationCounter);
<span class="fc" id="L191">        this.timer = timer;</span>
<span class="fc" id="L192">        this.minNumRacksPerWriteQuorum = minNumRacksPerWriteQuorum;</span>
<span class="fc" id="L193">        this.enforceMinNumRacksPerWriteQuorum = enforceMinNumRacksPerWriteQuorum;</span>
<span class="fc" id="L194">        this.ignoreLocalNodeInPlacementPolicy = ignoreLocalNodeInPlacementPolicy;</span>

        // create the network topology
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (stabilizePeriodSeconds &gt; 0) {</span>
<span class="nc" id="L198">            this.topology = new StabilizeNetworkTopology(timer, stabilizePeriodSeconds);</span>
        } else {
<span class="fc" id="L200">            this.topology = new NetworkTopologyImpl();</span>
        }

<span class="fc" id="L203">        BookieNode bn = null;</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (!ignoreLocalNodeInPlacementPolicy) {</span>
            try {
<span class="fc" id="L206">                bn = createBookieNode(new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(), 0));</span>
<span class="nc" id="L207">            } catch (UnknownHostException e) {</span>
<span class="nc" id="L208">                LOG.error(&quot;Failed to get local host address : &quot;, e);</span>
<span class="pc" id="L209">            }</span>
        } else {
<span class="nc" id="L211">            LOG.info(&quot;Ignoring LocalNode in Placementpolicy&quot;);</span>
        }
<span class="fc" id="L213">        localNode = bn;</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        LOG.info(&quot;Initialize rackaware ensemble placement policy @ {} @ {} : {}.&quot;,</span>
<span class="fc" id="L215">                localNode, null == localNode ? &quot;Unknown&quot; : localNode.getNetworkLocation(),</span>
<span class="fc" id="L216">                dnsResolver.getClass().getName());</span>

<span class="fc" id="L218">        this.isWeighted = isWeighted;</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        if (this.isWeighted) {</span>
<span class="nc" id="L220">            this.maxWeightMultiple = maxWeightMultiple;</span>
<span class="nc" id="L221">            this.weightedSelection = new WeightedRandomSelectionImpl&lt;BookieNode&gt;(this.maxWeightMultiple);</span>
<span class="nc" id="L222">            LOG.info(&quot;Weight based placement with max multiple of &quot; + this.maxWeightMultiple);</span>
        } else {
<span class="fc" id="L224">            LOG.info(&quot;Not weighted&quot;);</span>
        }
<span class="fc" id="L226">        return this;</span>
    }

    /*
     * sets default rack for the policy.
     * i.e. region-aware policy may want to have /region/rack while regular
     * rack-aware policy needs /rack only since we cannot mix both styles
     */
    public RackawareEnsemblePlacementPolicyImpl withDefaultRack(String rack) {
<span class="nc" id="L235">        checkNotNull(rack, &quot;Default rack cannot be null&quot;);</span>

<span class="nc" id="L237">        this.defaultRack = rack;</span>
<span class="nc" id="L238">        return this;</span>
    }

    public String getDefaultRack() {
<span class="fc" id="L242">        return defaultRack;</span>
    }

    @Override
    public RackawareEnsemblePlacementPolicyImpl initialize(ClientConfiguration conf,
                                                           Optional&lt;DNSToSwitchMapping&gt; optionalDnsResolver,
                                                           HashedWheelTimer timer,
                                                           FeatureProvider featureProvider,
                                                           StatsLogger statsLogger) {
        DNSToSwitchMapping dnsResolver;
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (optionalDnsResolver.isPresent()) {</span>
<span class="nc" id="L253">            dnsResolver = optionalDnsResolver.get();</span>
        } else {
<span class="fc" id="L255">            String dnsResolverName = conf.getString(REPP_DNS_RESOLVER_CLASS, ScriptBasedMapping.class.getName());</span>
            try {
<span class="fc" id="L257">                dnsResolver = ReflectionUtils.newInstance(dnsResolverName, DNSToSwitchMapping.class);</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">                if (dnsResolver instanceof Configurable) {</span>
<span class="nc" id="L259">                    ((Configurable) dnsResolver).setConf(conf);</span>
                }

<span class="nc bnc" id="L262" title="All 2 branches missed.">                if (dnsResolver instanceof RackChangeNotifier) {</span>
<span class="nc" id="L263">                    ((RackChangeNotifier) dnsResolver).registerRackChangeListener(this);</span>
                }
<span class="fc" id="L265">            } catch (RuntimeException re) {</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">                if (!conf.getEnforceMinNumRacksPerWriteQuorum()) {</span>
<span class="fc" id="L267">                    LOG.error(&quot;Failed to initialize DNS Resolver {}, used default subnet resolver : {}&quot;,</span>
<span class="fc" id="L268">                            dnsResolverName, re, re.getMessage());</span>
<span class="fc" id="L269">                    dnsResolver = new DefaultResolver(() -&gt; this.getDefaultRack());</span>
                } else {
                    /*
                     * if minNumRacksPerWriteQuorum is enforced, then it
                     * shouldn't continue in the case of failure to create
                     * dnsResolver.
                     */
<span class="nc" id="L276">                    throw re;</span>
                }
<span class="nc" id="L278">            }</span>
        }
<span class="fc" id="L280">        slowBookies = CacheBuilder.newBuilder()</span>
<span class="fc" id="L281">            .expireAfterWrite(conf.getBookieFailureHistoryExpirationMSec(), TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L282">            .build(new CacheLoader&lt;BookieSocketAddress, Long&gt;() {</span>
                @Override
                public Long load(BookieSocketAddress key) throws Exception {
<span class="nc" id="L285">                    return -1L;</span>
                }
            });
<span class="fc" id="L288">        return initialize(</span>
                dnsResolver,
                timer,
<span class="fc" id="L291">                conf.getBoolean(REPP_RANDOM_READ_REORDERING, false),</span>
<span class="fc" id="L292">                conf.getNetworkTopologyStabilizePeriodSeconds(),</span>
<span class="fc" id="L293">                conf.getReorderThresholdPendingRequests(),</span>
<span class="fc" id="L294">                conf.getDiskWeightBasedPlacementEnabled(),</span>
<span class="fc" id="L295">                conf.getBookieMaxWeightMultipleForWeightBasedPlacement(),</span>
<span class="fc" id="L296">                conf.getMinNumRacksPerWriteQuorum(),</span>
<span class="fc" id="L297">                conf.getEnforceMinNumRacksPerWriteQuorum(),</span>
<span class="fc" id="L298">                conf.getIgnoreLocalNodeInPlacementPolicy(),</span>
                statsLogger);
    }

    @Override
    public void uninitalize() {
        // do nothing
<span class="nc" id="L305">    }</span>

    /*
     * this method should be called in readlock scope of 'rwLock'
     */
    protected Set&lt;BookieSocketAddress&gt; addDefaultRackBookiesIfMinNumRacksIsEnforced(
            Set&lt;BookieSocketAddress&gt; excludeBookies) {
        Set&lt;BookieSocketAddress&gt; comprehensiveExclusionBookiesSet;
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (enforceMinNumRacksPerWriteQuorum) {</span>
<span class="nc" id="L314">            Set&lt;BookieSocketAddress&gt; bookiesInDefaultRack = null;</span>
<span class="nc" id="L315">            Set&lt;Node&gt; defaultRackLeaves = topology.getLeaves(getDefaultRack());</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            for (Node node : defaultRackLeaves) {</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                if (node instanceof BookieNode) {</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                    if (bookiesInDefaultRack == null) {</span>
<span class="nc" id="L319">                        bookiesInDefaultRack = new HashSet&lt;BookieSocketAddress&gt;(excludeBookies);</span>
                    }
<span class="nc" id="L321">                    bookiesInDefaultRack.add(((BookieNode) node).getAddr());</span>
                } else {
<span class="nc" id="L323">                    LOG.error(&quot;found non-BookieNode: {} as leaf of defaultrack: {}&quot;, node, getDefaultRack());</span>
                }
<span class="nc" id="L325">            }</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">            if ((bookiesInDefaultRack == null) || bookiesInDefaultRack.isEmpty()) {</span>
<span class="nc" id="L327">                comprehensiveExclusionBookiesSet = excludeBookies;</span>
            } else {
<span class="nc" id="L329">                comprehensiveExclusionBookiesSet = new HashSet&lt;BookieSocketAddress&gt;(excludeBookies);</span>
<span class="nc" id="L330">                comprehensiveExclusionBookiesSet.addAll(bookiesInDefaultRack);</span>
<span class="nc" id="L331">                LOG.info(&quot;enforceMinNumRacksPerWriteQuorum is enabled, so Excluding bookies of defaultRack: {}&quot;,</span>
                        bookiesInDefaultRack);
            }
<span class="nc" id="L334">        } else {</span>
<span class="fc" id="L335">            comprehensiveExclusionBookiesSet = excludeBookies;</span>
        }
<span class="fc" id="L337">        return comprehensiveExclusionBookiesSet;</span>
    }

    @Override
    public PlacementResult&lt;List&lt;BookieSocketAddress&gt;&gt; newEnsemble(int ensembleSize, int writeQuorumSize,
            int ackQuorumSize, Map&lt;String, byte[]&gt; customMetadata, Set&lt;BookieSocketAddress&gt; excludeBookies)
            throws BKNotEnoughBookiesException {
<span class="fc" id="L344">        rwLock.readLock().lock();</span>
        try {
<span class="fc" id="L346">            Set&lt;BookieSocketAddress&gt; comprehensiveExclusionBookiesSet = addDefaultRackBookiesIfMinNumRacksIsEnforced(</span>
                    excludeBookies);
<span class="fc" id="L348">            PlacementResult&lt;List&lt;BookieSocketAddress&gt;&gt; newEnsembleResult = newEnsembleInternal(ensembleSize,</span>
                    writeQuorumSize, ackQuorumSize, comprehensiveExclusionBookiesSet, null, null);
<span class="fc" id="L350">            return newEnsembleResult;</span>
        } finally {
<span class="fc" id="L352">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public PlacementResult&lt;List&lt;BookieSocketAddress&gt;&gt; newEnsemble(int ensembleSize,
                                                                  int writeQuorumSize,
                                                                  int ackQuorumSize,
                                                                  Set&lt;BookieSocketAddress&gt; excludeBookies,
                                                                  Ensemble&lt;BookieNode&gt; parentEnsemble,
                                                                  Predicate&lt;BookieNode&gt; parentPredicate)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L364">        return newEnsembleInternal(</span>
                ensembleSize,
                writeQuorumSize,
                ackQuorumSize,
                excludeBookies,
                parentEnsemble,
                parentPredicate);
    }

    protected PlacementResult&lt;List&lt;BookieSocketAddress&gt;&gt; newEnsembleInternal(
            int ensembleSize,
            int writeQuorumSize,
            int ackQuorumSize,
            Set&lt;BookieSocketAddress&gt; excludeBookies,
            Ensemble&lt;BookieNode&gt; parentEnsemble,
            Predicate&lt;BookieNode&gt; parentPredicate) throws BKNotEnoughBookiesException {
<span class="fc" id="L380">        rwLock.readLock().lock();</span>
        try {
<span class="fc" id="L382">            Set&lt;Node&gt; excludeNodes = convertBookiesToNodes(excludeBookies);</span>
<span class="fc" id="L383">            int minNumRacksPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>
<span class="fc" id="L384">            RRTopologyAwareCoverageEnsemble ensemble =</span>
                    new RRTopologyAwareCoverageEnsemble(
                            ensembleSize,
                            writeQuorumSize,
                            ackQuorumSize,
                            RACKNAME_DISTANCE_FROM_LEAVES,
                            parentEnsemble,
                            parentPredicate,
                            minNumRacksPerWriteQuorumForThisEnsemble);
<span class="fc" id="L393">            BookieNode prevNode = null;</span>
<span class="fc" id="L394">            int numRacks = topology.getNumOfRacks();</span>
            // only one rack, use the random algorithm.
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">            if (numRacks &lt; 2) {</span>
<span class="pc bpc" id="L397" title="3 of 4 branches missed.">                if (enforceMinNumRacksPerWriteQuorum &amp;&amp; (minNumRacksPerWriteQuorumForThisEnsemble &gt; 1)) {</span>
<span class="nc" id="L398">                    LOG.error(&quot;Only one rack available and minNumRacksPerWriteQuorum is enforced, so giving up&quot;);</span>
<span class="nc" id="L399">                    throw new BKNotEnoughBookiesException();</span>
                }
<span class="fc" id="L401">                List&lt;BookieNode&gt; bns = selectRandom(ensembleSize, excludeNodes, TruePredicate.INSTANCE,</span>
                        ensemble);
<span class="fc" id="L403">                ArrayList&lt;BookieSocketAddress&gt; addrs = new ArrayList&lt;BookieSocketAddress&gt;(ensembleSize);</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">                for (BookieNode bn : bns) {</span>
<span class="fc" id="L405">                    addrs.add(bn.getAddr());</span>
<span class="fc" id="L406">                }</span>
<span class="fc" id="L407">                return PlacementResult.of(addrs, PlacementPolicyAdherence.FAIL);</span>
            }

<span class="nc bnc" id="L410" title="All 2 branches missed.">            for (int i = 0; i &lt; ensembleSize; i++) {</span>
                String curRack;
<span class="nc bnc" id="L412" title="All 2 branches missed.">                if (null == prevNode) {</span>
<span class="nc bnc" id="L413" title="All 4 branches missed.">                    if ((null == localNode) || defaultRack.equals(localNode.getNetworkLocation())) {</span>
<span class="nc" id="L414">                        curRack = NodeBase.ROOT;</span>
                    } else {
<span class="nc" id="L416">                        curRack = localNode.getNetworkLocation();</span>
                    }
                } else {
<span class="nc" id="L419">                    curRack = &quot;~&quot; + prevNode.getNetworkLocation();</span>
                }
<span class="nc bnc" id="L421" title="All 2 branches missed.">                boolean firstBookieInTheEnsemble = (null == prevNode);</span>
<span class="nc bnc" id="L422" title="All 4 branches missed.">                prevNode = selectFromNetworkLocation(curRack, excludeNodes, ensemble, ensemble,</span>
                        !enforceMinNumRacksPerWriteQuorum || firstBookieInTheEnsemble);
            }
<span class="nc" id="L425">            List&lt;BookieSocketAddress&gt; bookieList = ensemble.toList();</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            if (ensembleSize != bookieList.size()) {</span>
<span class="nc" id="L427">                LOG.error(&quot;Not enough {} bookies are available to form an ensemble : {}.&quot;,</span>
<span class="nc" id="L428">                          ensembleSize, bookieList);</span>
<span class="nc" id="L429">                throw new BKNotEnoughBookiesException();</span>
            }
<span class="nc" id="L431">            return PlacementResult.of(bookieList,</span>
<span class="nc" id="L432">                                      isEnsembleAdheringToPlacementPolicy(</span>
                                              bookieList, writeQuorumSize, ackQuorumSize));
        } finally {
<span class="fc" id="L435">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public PlacementResult&lt;BookieSocketAddress&gt; replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize,
            Map&lt;String, byte[]&gt; customMetadata, List&lt;BookieSocketAddress&gt; currentEnsemble,
            BookieSocketAddress bookieToReplace, Set&lt;BookieSocketAddress&gt; excludeBookies)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L444">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L446">            excludeBookies = addDefaultRackBookiesIfMinNumRacksIsEnforced(excludeBookies);</span>
<span class="nc" id="L447">            excludeBookies.addAll(currentEnsemble);</span>
<span class="nc" id="L448">            BookieNode bn = knownBookies.get(bookieToReplace);</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">            if (null == bn) {</span>
<span class="nc" id="L450">                bn = createBookieNode(bookieToReplace);</span>
            }

<span class="nc" id="L453">            Set&lt;Node&gt; ensembleNodes = convertBookiesToNodes(currentEnsemble);</span>
<span class="nc" id="L454">            Set&lt;Node&gt; excludeNodes = convertBookiesToNodes(excludeBookies);</span>

<span class="nc" id="L456">            excludeNodes.addAll(ensembleNodes);</span>
<span class="nc" id="L457">            excludeNodes.add(bn);</span>
<span class="nc" id="L458">            ensembleNodes.remove(bn);</span>

<span class="nc" id="L460">            Set&lt;String&gt; networkLocationsToBeExcluded = getNetworkLocations(ensembleNodes);</span>

<span class="nc bnc" id="L462" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L463">                LOG.debug(&quot;Try to choose a new bookie to replace {} from ensemble {}, excluding {}.&quot;,</span>
                    bookieToReplace, ensembleNodes, excludeNodes);
            }
            // pick a candidate from same rack to replace
<span class="nc" id="L467">            BookieNode candidate = selectFromNetworkLocation(</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">                    bn.getNetworkLocation(),</span>
                    networkLocationsToBeExcluded,
                    excludeNodes,
                    TruePredicate.INSTANCE,
                    EnsembleForReplacementWithNoConstraints.INSTANCE,
                    !enforceMinNumRacksPerWriteQuorum);
<span class="nc bnc" id="L474" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L475">                LOG.debug(&quot;Bookie {} is chosen to replace bookie {}.&quot;, candidate, bn);</span>
            }
<span class="nc" id="L477">            BookieSocketAddress candidateAddr = candidate.getAddr();</span>
<span class="nc" id="L478">            List&lt;BookieSocketAddress&gt; newEnsemble = new ArrayList&lt;BookieSocketAddress&gt;(currentEnsemble);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">            if (currentEnsemble.isEmpty()) {</span>
                /*
                 * in testing code there are test cases which would pass empty
                 * currentEnsemble
                 */
<span class="nc" id="L484">                newEnsemble.add(candidateAddr);</span>
            } else {
<span class="nc" id="L486">                newEnsemble.set(currentEnsemble.indexOf(bookieToReplace), candidateAddr);</span>
            }
<span class="nc" id="L488">            return PlacementResult.of(candidateAddr,</span>
<span class="nc" id="L489">                    isEnsembleAdheringToPlacementPolicy(newEnsemble, writeQuorumSize, ackQuorumSize));</span>
        } finally {
<span class="nc" id="L491">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public BookieNode selectFromNetworkLocation(
            String networkLoc,
            Set&lt;Node&gt; excludeBookies,
            Predicate&lt;BookieNode&gt; predicate,
            Ensemble&lt;BookieNode&gt; ensemble,
            boolean fallbackToRandom)
            throws BKNotEnoughBookiesException {
        // select one from local rack
        try {
<span class="nc" id="L505">            return selectRandomFromRack(networkLoc, excludeBookies, predicate, ensemble);</span>
<span class="nc" id="L506">        } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">            if (!fallbackToRandom) {</span>
<span class="nc" id="L508">                LOG.error(</span>
                        &quot;Failed to choose a bookie from {} : &quot;
                                + &quot;excluded {}, enforceMinNumRacksPerWriteQuorum is enabled so giving up.&quot;,
                        networkLoc, excludeBookies);
<span class="nc" id="L512">                throw e;</span>
            }
<span class="nc" id="L514">            LOG.warn(&quot;Failed to choose a bookie from {} : &quot;</span>
                     + &quot;excluded {}, fallback to choose bookie randomly from the cluster.&quot;,
                     networkLoc, excludeBookies);
            // randomly choose one from whole cluster, ignore the provided predicate.
<span class="nc" id="L518">            return selectRandom(1, excludeBookies, predicate, ensemble).get(0);</span>
        }
    }

    @Override
    public BookieNode selectFromNetworkLocation(String networkLoc,
                                                   Set&lt;String&gt; excludeRacks,
                                                   Set&lt;Node&gt; excludeBookies,
                                                   Predicate&lt;BookieNode&gt; predicate,
                                                   Ensemble&lt;BookieNode&gt; ensemble,
                                                   boolean fallbackToRandom)
            throws BKNotEnoughBookiesException {
        // first attempt to select one from local rack
        try {
<span class="nc" id="L532">            return selectRandomFromRack(networkLoc, excludeBookies, predicate, ensemble);</span>
<span class="nc" id="L533">        } catch (BKNotEnoughBookiesException e) {</span>
            /*
             * there is no enough bookie from local rack, select bookies from
             * the whole cluster and exclude the racks specified at
             * &lt;tt&gt;excludeRacks&lt;/tt&gt;.
             */
<span class="nc" id="L539">            return selectFromNetworkLocation(excludeRacks, excludeBookies, predicate, ensemble, fallbackToRandom);</span>
        }
    }


    /**
     * It randomly selects a {@link BookieNode} that is not on the &lt;i&gt;excludeRacks&lt;/i&gt; set, excluding the nodes in
     * &lt;i&gt;excludeBookies&lt;/i&gt; set. If it fails to find one, it selects a random {@link BookieNode} from the whole
     * cluster.
     */
    @Override
    public BookieNode selectFromNetworkLocation(Set&lt;String&gt; excludeRacks,
                                                   Set&lt;Node&gt; excludeBookies,
                                                   Predicate&lt;BookieNode&gt; predicate,
                                                   Ensemble&lt;BookieNode&gt; ensemble,
                                                   boolean fallbackToRandom)
            throws BKNotEnoughBookiesException {

<span class="nc" id="L557">        List&lt;BookieNode&gt; knownNodes = new ArrayList&lt;&gt;(knownBookies.values());</span>
<span class="nc" id="L558">        Set&lt;Node&gt; fullExclusionBookiesList = new HashSet&lt;Node&gt;(excludeBookies);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">        for (BookieNode knownNode : knownNodes) {</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">            if (excludeRacks.contains(knownNode.getNetworkLocation())) {</span>
<span class="nc" id="L561">                fullExclusionBookiesList.add(knownNode);</span>
            }
<span class="nc" id="L563">        }</span>

        try {
<span class="nc" id="L566">            return selectRandomInternal(knownNodes, 1, fullExclusionBookiesList, predicate, ensemble).get(0);</span>
<span class="nc" id="L567">        } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">            if (!fallbackToRandom) {</span>
<span class="nc" id="L569">                LOG.error(</span>
                        &quot;Failed to choose a bookie excluding Racks: {} &quot;
                                + &quot;Nodes: {}, enforceMinNumRacksPerWriteQuorum is enabled so giving up.&quot;,
                        excludeRacks, excludeBookies);
<span class="nc" id="L573">                throw e;</span>
            }

<span class="nc" id="L576">            LOG.warn(&quot;Failed to choose a bookie: excluded {}, fallback to choose bookie randomly from the cluster.&quot;,</span>
                    excludeBookies);
            // randomly choose one from whole cluster
<span class="nc" id="L579">            return selectRandom(1, excludeBookies, predicate, ensemble).get(0);</span>
        }
    }

    private WeightedRandomSelection&lt;BookieNode&gt; prepareForWeightedSelection(List&lt;Node&gt; leaves) {
        // create a map of bookieNode-&gt;freeDiskSpace for this rack. The assumption is that
        // the number of nodes in a rack is of the order of 40, so it shouldn't be too bad
        // to build it every time during a ledger creation
<span class="nc" id="L587">        Map&lt;BookieNode, WeightedObject&gt; rackMap = new HashMap&lt;BookieNode, WeightedObject&gt;();</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">        for (Node n : leaves) {</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">            if (!(n instanceof BookieNode)) {</span>
<span class="nc" id="L590">                continue;</span>
            }
<span class="nc" id="L592">            BookieNode bookie = (BookieNode) n;</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">            if (this.bookieInfoMap.containsKey(bookie)) {</span>
<span class="nc" id="L594">                rackMap.put(bookie, this.bookieInfoMap.get(bookie));</span>
            } else {
<span class="nc" id="L596">                rackMap.put(bookie, new BookieInfo());</span>
            }
<span class="nc" id="L598">        }</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (rackMap.size() == 0) {</span>
<span class="nc" id="L600">            return null;</span>
        }

<span class="nc" id="L603">        WeightedRandomSelection&lt;BookieNode&gt; wRSelection = new WeightedRandomSelectionImpl&lt;BookieNode&gt;(</span>
                maxWeightMultiple);
<span class="nc" id="L605">        wRSelection.updateMap(rackMap);</span>
<span class="nc" id="L606">        return wRSelection;</span>
    }

    /**
     * Choose random node under a given network path.
     *
     * @param netPath
     *          network path
     * @param excludeBookies
     *          exclude bookies
     * @param predicate
     *          predicate to check whether the target is a good target.
     * @param ensemble
     *          ensemble structure
     * @return chosen bookie.
     */
    protected BookieNode selectRandomFromRack(String netPath, Set&lt;Node&gt; excludeBookies, Predicate&lt;BookieNode&gt; predicate,
            Ensemble&lt;BookieNode&gt; ensemble) throws BKNotEnoughBookiesException {
<span class="nc" id="L624">        WeightedRandomSelection&lt;BookieNode&gt; wRSelection = null;</span>
<span class="nc" id="L625">        List&lt;Node&gt; leaves = new ArrayList&lt;Node&gt;(topology.getLeaves(netPath));</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">        if (!this.isWeighted) {</span>
<span class="nc" id="L627">            Collections.shuffle(leaves);</span>
        } else {
<span class="nc bnc" id="L629" title="All 2 branches missed.">            if (CollectionUtils.subtract(leaves, excludeBookies).size() &lt; 1) {</span>
<span class="nc" id="L630">                throw new BKNotEnoughBookiesException();</span>
            }
<span class="nc" id="L632">            wRSelection = prepareForWeightedSelection(leaves);</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">            if (wRSelection == null) {</span>
<span class="nc" id="L634">                throw new BKNotEnoughBookiesException();</span>
            }
        }

<span class="nc" id="L638">        Iterator&lt;Node&gt; it = leaves.iterator();</span>
<span class="nc" id="L639">        Set&lt;Node&gt; bookiesSeenSoFar = new HashSet&lt;Node&gt;();</span>
        while (true) {
            Node n;
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (isWeighted) {</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                if (bookiesSeenSoFar.size() == leaves.size()) {</span>
                    // Don't loop infinitely.
<span class="nc" id="L645">                    break;</span>
                }
<span class="nc" id="L647">                n = wRSelection.getNextRandom();</span>
<span class="nc" id="L648">                bookiesSeenSoFar.add(n);</span>
            } else {
<span class="nc bnc" id="L650" title="All 2 branches missed.">                if (it.hasNext()) {</span>
<span class="nc" id="L651">                    n = it.next();</span>
                } else {
                    break;
                }
            }
<span class="nc bnc" id="L656" title="All 2 branches missed.">            if (excludeBookies.contains(n)) {</span>
<span class="nc" id="L657">                continue;</span>
            }
<span class="nc bnc" id="L659" title="All 4 branches missed.">            if (!(n instanceof BookieNode) || !predicate.apply((BookieNode) n, ensemble)) {</span>
<span class="nc" id="L660">                continue;</span>
            }
<span class="nc" id="L662">            BookieNode bn = (BookieNode) n;</span>
            // got a good candidate
<span class="nc bnc" id="L664" title="All 2 branches missed.">            if (ensemble.addNode(bn)) {</span>
                // add the candidate to exclude set
<span class="nc" id="L666">                excludeBookies.add(bn);</span>
            }
<span class="nc" id="L668">            return bn;</span>
        }
<span class="nc" id="L670">        throw new BKNotEnoughBookiesException();</span>
    }

    /**
     * Choose a random node from whole cluster.
     *
     * @param numBookies
     *          number bookies to choose
     * @param excludeBookies
     *          bookies set to exclude.
     * @param ensemble
     *          ensemble to hold the bookie chosen.
     * @return the bookie node chosen.
     * @throws BKNotEnoughBookiesException
     */
    protected List&lt;BookieNode&gt; selectRandom(int numBookies,
                                            Set&lt;Node&gt; excludeBookies,
                                            Predicate&lt;BookieNode&gt; predicate,
                                            Ensemble&lt;BookieNode&gt; ensemble)
            throws BKNotEnoughBookiesException {
<span class="fc" id="L690">        return selectRandomInternal(null,  numBookies, excludeBookies, predicate, ensemble);</span>
    }

    protected List&lt;BookieNode&gt; selectRandomInternal(List&lt;BookieNode&gt; bookiesToSelectFrom,
                                                    int numBookies,
                                                    Set&lt;Node&gt; excludeBookies,
                                                    Predicate&lt;BookieNode&gt; predicate,
                                                    Ensemble&lt;BookieNode&gt; ensemble)
        throws BKNotEnoughBookiesException {
<span class="fc" id="L699">        WeightedRandomSelection&lt;BookieNode&gt; wRSelection = null;</span>
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">        if (bookiesToSelectFrom == null) {</span>
            // If the list is null, we need to select from the entire knownBookies set
<span class="fc" id="L702">            wRSelection = this.weightedSelection;</span>
<span class="fc" id="L703">            bookiesToSelectFrom = new ArrayList&lt;BookieNode&gt;(knownBookies.values());</span>
        }
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">        if (isWeighted) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">            if (CollectionUtils.subtract(bookiesToSelectFrom, excludeBookies).size() &lt; numBookies) {</span>
<span class="nc" id="L707">                throw new BKNotEnoughBookiesException();</span>
            }
<span class="nc bnc" id="L709" title="All 2 branches missed.">            if (wRSelection == null) {</span>
<span class="nc" id="L710">                Map&lt;BookieNode, WeightedObject&gt; rackMap = new HashMap&lt;BookieNode, WeightedObject&gt;();</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">                for (BookieNode n : bookiesToSelectFrom) {</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                    if (excludeBookies.contains(n)) {</span>
<span class="nc" id="L713">                        continue;</span>
                    }
<span class="nc bnc" id="L715" title="All 2 branches missed.">                    if (this.bookieInfoMap.containsKey(n)) {</span>
<span class="nc" id="L716">                        rackMap.put(n, this.bookieInfoMap.get(n));</span>
                    } else {
<span class="nc" id="L718">                        rackMap.put(n, new BookieInfo());</span>
                    }
<span class="nc" id="L720">                }</span>
<span class="nc" id="L721">                wRSelection = new WeightedRandomSelectionImpl&lt;BookieNode&gt;(this.maxWeightMultiple);</span>
<span class="nc" id="L722">                wRSelection.updateMap(rackMap);</span>
<span class="nc" id="L723">            }</span>
        } else {
<span class="fc" id="L725">            Collections.shuffle(bookiesToSelectFrom);</span>
        }

        BookieNode bookie;
<span class="fc" id="L729">        List&lt;BookieNode&gt; newBookies = new ArrayList&lt;BookieNode&gt;(numBookies);</span>
<span class="fc" id="L730">        Iterator&lt;BookieNode&gt; it = bookiesToSelectFrom.iterator();</span>
<span class="fc" id="L731">        Set&lt;BookieNode&gt; bookiesSeenSoFar = new HashSet&lt;BookieNode&gt;();</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">        while (numBookies &gt; 0) {</span>
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">            if (isWeighted) {</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">                if (bookiesSeenSoFar.size() == bookiesToSelectFrom.size()) {</span>
                    // If we have gone through the whole available list of bookies,
                    // and yet haven't been able to satisfy the ensemble request, bail out.
                    // We don't want to loop infinitely.
<span class="nc" id="L738">                    break;</span>
                }
<span class="nc" id="L740">                bookie = wRSelection.getNextRandom();</span>
<span class="nc" id="L741">                bookiesSeenSoFar.add(bookie);</span>
            } else {
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">                if (it.hasNext()) {</span>
<span class="fc" id="L744">                    bookie = it.next();</span>
                } else {
                    break;
                }
            }
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">            if (excludeBookies.contains(bookie)) {</span>
<span class="nc" id="L750">                continue;</span>
            }

            // When durability is being enforced; we must not violate the
            // predicate even when selecting a random bookie; as durability
            // guarantee is not best effort; correctness is implied by it
<span class="pc bpc" id="L756" title="3 of 4 branches missed.">            if (enforceDurability &amp;&amp; !predicate.apply(bookie, ensemble)) {</span>
<span class="nc" id="L757">                continue;</span>
            }

<span class="pc bpc" id="L760" title="1 of 2 branches missed.">            if (ensemble.addNode(bookie)) {</span>
<span class="fc" id="L761">                excludeBookies.add(bookie);</span>
<span class="fc" id="L762">                newBookies.add(bookie);</span>
<span class="fc" id="L763">                --numBookies;</span>
            }
        }
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">        if (numBookies == 0) {</span>
<span class="fc" id="L767">            return newBookies;</span>
        }
<span class="nc" id="L769">        LOG.warn(&quot;Failed to find {} bookies : excludeBookies {}, allBookies {}.&quot;,</span>
<span class="nc" id="L770">            numBookies, excludeBookies, bookiesToSelectFrom);</span>

<span class="nc" id="L772">        throw new BKNotEnoughBookiesException();</span>
    }

    @Override
    public void registerSlowBookie(BookieSocketAddress bookieSocketAddress, long entryId) {
<span class="nc bnc" id="L777" title="All 2 branches missed.">        if (reorderThresholdPendingRequests &lt;= 0) {</span>
            // only put bookies on slowBookies list if reorderThresholdPendingRequests is *not* set (0);
            // otherwise, rely on reordering of reads based on reorderThresholdPendingRequests
<span class="nc" id="L780">            slowBookies.put(bookieSocketAddress, entryId);</span>
        }
<span class="nc" id="L782">    }</span>

    @Override
    public DistributionSchedule.WriteSet reorderReadSequence(
            List&lt;BookieSocketAddress&gt; ensemble,
            BookiesHealthInfo bookiesHealthInfo,
            DistributionSchedule.WriteSet writeSet) {
<span class="nc" id="L789">        Map&lt;Integer, String&gt; writeSetWithRegion = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L791">            writeSetWithRegion.put(writeSet.get(i), &quot;&quot;);</span>
        }
<span class="nc" id="L793">        return reorderReadSequenceWithRegion(</span>
<span class="nc" id="L794">            ensemble, writeSet, writeSetWithRegion, bookiesHealthInfo, false, &quot;&quot;, writeSet.size());</span>
    }

    /**
     * This function orders the read sequence with a given region. For region-unaware policies (e.g.
     * RackAware), we pass in false for regionAware and an empty myRegion. When this happens, any
     * remote list will stay empty. The ordering is as follows (the R* at the beginning of each list item
     * is only present for region aware policies).
     *      1. available (local) bookies
     *      2. R* a remote bookie (based on remoteNodeInReorderSequence
     *      3. R* remaining (local) bookies
     *      4. R* remaining remote bookies
     *      5. read only bookies
     *      6. slow bookies
     *      7. unavailable bookies
     *
     * @param ensemble
     *          ensemble of bookies
     * @param writeSet
     *          write set
     * @param writeSetWithRegion
     *          write set with region information
     * @param bookiesHealthInfo
     *          heuristics about health of boookies
     * @param regionAware
     *          whether or not a region-aware policy is used
     * @param myRegion
     *          current region of policy
     * @param remoteNodeInReorderSequence
     *          number of local bookies to try before trying a remote bookie
     * @return ordering of bookies to send read to
     */
    DistributionSchedule.WriteSet reorderReadSequenceWithRegion(
        List&lt;BookieSocketAddress&gt; ensemble,
        DistributionSchedule.WriteSet writeSet,
        Map&lt;Integer, String&gt; writeSetWithRegion,
        BookiesHealthInfo bookiesHealthInfo,
        boolean regionAware,
        String myRegion,
        int remoteNodeInReorderSequence) {
<span class="nc bnc" id="L834" title="All 4 branches missed.">        boolean useRegionAware = regionAware &amp;&amp; (!myRegion.equals(UNKNOWN_REGION));</span>
<span class="nc" id="L835">        int ensembleSize = ensemble.size();</span>

        // For rack aware, If all the bookies in the write set are available, simply return the original write set,
        // to avoid creating more lists
<span class="nc" id="L839">        boolean isAnyBookieUnavailable = false;</span>

<span class="nc bnc" id="L841" title="All 4 branches missed.">        if (useRegionAware || reorderReadsRandom) {</span>
<span class="nc" id="L842">            isAnyBookieUnavailable = true;</span>
        } else {
<span class="nc bnc" id="L844" title="All 2 branches missed.">            for (int i = 0; i &lt; ensemble.size(); i++) {</span>
<span class="nc" id="L845">                BookieSocketAddress bookieAddr = ensemble.get(i);</span>
<span class="nc bnc" id="L846" title="All 4 branches missed.">                if ((!knownBookies.containsKey(bookieAddr) &amp;&amp; !readOnlyBookies.contains(bookieAddr))</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">                    || slowBookies.getIfPresent(bookieAddr) != null) {</span>
                    // Found at least one bookie not available in the ensemble, or in slowBookies
<span class="nc" id="L849">                    isAnyBookieUnavailable = true;</span>
<span class="nc" id="L850">                    break;</span>
                }
            }
        }

<span class="nc" id="L855">        boolean reordered = false;</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">        if (reorderThresholdPendingRequests &gt; 0) {</span>
            // if there are no slow or unavailable bookies, capture each bookie's number of
            // pending request to reorder requests based on a threshold of pending requests

            // number of pending requests per bookie (same index as writeSet)
<span class="nc" id="L861">            long[] pendingReqs = new long[writeSet.size()];</span>
<span class="nc" id="L862">            int bestBookieIdx = -1;</span>

<span class="nc bnc" id="L864" title="All 2 branches missed.">            for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L865">                pendingReqs[i] = bookiesHealthInfo.getBookiePendingRequests(ensemble.get(writeSet.get(i)));</span>
<span class="nc bnc" id="L866" title="All 4 branches missed.">                if (bestBookieIdx &lt; 0 || pendingReqs[i] &lt; pendingReqs[bestBookieIdx]) {</span>
<span class="nc" id="L867">                    bestBookieIdx = i;</span>
                }
            }

            // reorder the writeSet if the currently first bookie in our writeSet has at
            // least
            // reorderThresholdPendingRequests more outstanding request than the best bookie
<span class="nc bnc" id="L874" title="All 4 branches missed.">            if (bestBookieIdx &gt; 0 &amp;&amp; pendingReqs[0] &gt;= pendingReqs[bestBookieIdx] + reorderThresholdPendingRequests) {</span>
                // We're not reordering the entire write set, but only move the best bookie
                // to the first place. Chances are good that this bookie will be fast enough
                // to not trigger the speculativeReadTimeout. But even if it hits that timeout,
                // things may have changed by then so much that whichever bookie we put second
                // may actually not be the second-best choice any more.
<span class="nc bnc" id="L880" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L881">                    LOG.debug(&quot;read set reordered from {} ({} pending) to {} ({} pending)&quot;,</span>
<span class="nc" id="L882">                            ensemble.get(writeSet.get(0)), pendingReqs[0], ensemble.get(writeSet.get(bestBookieIdx)),</span>
<span class="nc" id="L883">                            pendingReqs[bestBookieIdx]);</span>
                }
<span class="nc" id="L885">                writeSet.moveAndShift(bestBookieIdx, 0);</span>
<span class="nc" id="L886">                reordered = true;</span>
            }
        }

<span class="nc bnc" id="L890" title="All 2 branches missed.">        if (!isAnyBookieUnavailable) {</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">            if (reordered) {</span>
<span class="nc" id="L892">                readReorderedCounter.registerSuccessfulValue(1);</span>
            }
<span class="nc" id="L894">            return writeSet;</span>
        }

<span class="nc bnc" id="L897" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L898">            int idx = writeSet.get(i);</span>
<span class="nc" id="L899">            BookieSocketAddress address = ensemble.get(idx);</span>
<span class="nc" id="L900">            String region = writeSetWithRegion.get(idx);</span>
<span class="nc" id="L901">            Long lastFailedEntryOnBookie = bookiesHealthInfo.getBookieFailureHistory(address);</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">            if (null == knownBookies.get(address)) {</span>
                // there isn't too much differences between readonly bookies
                // from unavailable bookies. since there
                // is no write requests to them, so we shouldn't try reading
                // from readonly bookie prior to writable bookies.
<span class="nc bnc" id="L907" title="All 2 branches missed.">                if ((null == readOnlyBookies)</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">                    || !readOnlyBookies.contains(address)) {</span>
<span class="nc" id="L909">                    writeSet.set(i, idx | UNAVAIL_MASK);</span>
                } else {
<span class="nc bnc" id="L911" title="All 2 branches missed.">                    if (slowBookies.getIfPresent(address) != null) {</span>
<span class="nc" id="L912">                        long numPendingReqs = bookiesHealthInfo.getBookiePendingRequests(address);</span>
                        // use slow bookies with less pending requests first
<span class="nc" id="L914">                        long slowIdx = numPendingReqs * ensembleSize + idx;</span>
<span class="nc" id="L915">                        writeSet.set(i, (int) (slowIdx &amp; ~MASK_BITS) | SLOW_MASK);</span>
<span class="nc" id="L916">                    } else {</span>
<span class="nc" id="L917">                        writeSet.set(i, idx | READ_ONLY_MASK);</span>
                    }
                }
<span class="nc bnc" id="L920" title="All 2 branches missed.">            } else if (lastFailedEntryOnBookie &lt; 0) {</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">                if (slowBookies.getIfPresent(address) != null) {</span>
<span class="nc" id="L922">                    long numPendingReqs = bookiesHealthInfo.getBookiePendingRequests(address);</span>
<span class="nc" id="L923">                    long slowIdx = numPendingReqs * ensembleSize + idx;</span>
<span class="nc" id="L924">                    writeSet.set(i, (int) (slowIdx &amp; ~MASK_BITS) | SLOW_MASK);</span>
<span class="nc" id="L925">                } else {</span>
<span class="nc bnc" id="L926" title="All 4 branches missed.">                    if (useRegionAware &amp;&amp; !myRegion.equals(region)) {</span>
<span class="nc" id="L927">                        writeSet.set(i, idx | REMOTE_MASK);</span>
                    } else {
<span class="nc" id="L929">                        writeSet.set(i, idx | LOCAL_MASK);</span>
                    }
                }
            } else {
                // use bookies with earlier failed entryIds first
<span class="nc" id="L934">                long failIdx = lastFailedEntryOnBookie * ensembleSize + idx;</span>
<span class="nc bnc" id="L935" title="All 4 branches missed.">                if (useRegionAware &amp;&amp; !myRegion.equals(region)) {</span>
<span class="nc" id="L936">                    writeSet.set(i, (int) (failIdx &amp; ~MASK_BITS) | REMOTE_FAIL_MASK);</span>
                } else {
<span class="nc" id="L938">                    writeSet.set(i, (int) (failIdx &amp; ~MASK_BITS) | LOCAL_FAIL_MASK);</span>
                }
            }
        }

        // Add a mask to ensure the sort is stable, sort,
        // and then remove mask. This maintains stability as
        // long as there are fewer than 16 bookies in the write set.
<span class="nc bnc" id="L946" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L947">            writeSet.set(i, writeSet.get(i) | ((i &amp; 0xF) &lt;&lt; 20));</span>
        }
<span class="nc" id="L949">        writeSet.sort();</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L951">            writeSet.set(i, writeSet.get(i) &amp; ~((0xF) &lt;&lt; 20));</span>
        }

<span class="nc bnc" id="L954" title="All 2 branches missed.">        if (reorderReadsRandom) {</span>
<span class="nc" id="L955">            shuffleWithMask(writeSet, LOCAL_MASK, MASK_BITS);</span>
<span class="nc" id="L956">            shuffleWithMask(writeSet, REMOTE_MASK, MASK_BITS);</span>
<span class="nc" id="L957">            shuffleWithMask(writeSet, READ_ONLY_MASK, MASK_BITS);</span>
<span class="nc" id="L958">            shuffleWithMask(writeSet, UNAVAIL_MASK, MASK_BITS);</span>
        }

        // nodes within a region are ordered as follows
        // (Random?) list of nodes that have no history of failure
        // Nodes with Failure history are ordered in the reverse
        // order of the most recent entry that generated an error
        // The sort will have put them in correct order,
        // so remove the bits that sort by age.
<span class="nc bnc" id="L967" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L968">            int mask = writeSet.get(i) &amp; MASK_BITS;</span>
<span class="nc" id="L969">            int idx = (writeSet.get(i) &amp; ~MASK_BITS) % ensembleSize;</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">            if (mask == LOCAL_FAIL_MASK) {</span>
<span class="nc" id="L971">                writeSet.set(i, LOCAL_MASK | idx);</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">            } else if (mask == REMOTE_FAIL_MASK) {</span>
<span class="nc" id="L973">                writeSet.set(i, REMOTE_MASK | idx);</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">            } else if (mask == SLOW_MASK) {</span>
<span class="nc" id="L975">                writeSet.set(i, SLOW_MASK | idx);</span>
            }
        }

        // Insert a node from the remote region at the specified location so
        // we try more than one region within the max allowed latency
<span class="nc" id="L981">        int firstRemote = -1;</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">            if ((writeSet.get(i) &amp; MASK_BITS) == REMOTE_MASK) {</span>
<span class="nc" id="L984">                firstRemote = i;</span>
<span class="nc" id="L985">                break;</span>
            }
        }
<span class="nc bnc" id="L988" title="All 2 branches missed.">        if (firstRemote != -1) {</span>
<span class="nc" id="L989">            int i = 0;</span>
            for (; i &lt; remoteNodeInReorderSequence
<span class="nc bnc" id="L991" title="All 4 branches missed.">                &amp;&amp; i &lt; writeSet.size(); i++) {</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">                if ((writeSet.get(i) &amp; MASK_BITS) != LOCAL_MASK) {</span>
<span class="nc" id="L993">                    break;</span>
                }
            }
<span class="nc" id="L996">            writeSet.moveAndShift(firstRemote, i);</span>
        }


        // remove all masks
<span class="nc bnc" id="L1001" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L1002">            writeSet.set(i, writeSet.get(i) &amp; ~MASK_BITS);</span>
        }
<span class="nc" id="L1004">        readReorderedCounter.registerSuccessfulValue(1);</span>
<span class="nc" id="L1005">        return writeSet;</span>
    }

    // this method should be called in readlock scope of 'rwlock'
    @Override
    public PlacementPolicyAdherence isEnsembleAdheringToPlacementPolicy(List&lt;BookieSocketAddress&gt; ensembleList,
            int writeQuorumSize, int ackQuorumSize) {
<span class="nc" id="L1012">        int ensembleSize = ensembleList.size();</span>
<span class="nc" id="L1013">        int minNumRacksPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>
<span class="nc" id="L1014">        HashSet&lt;String&gt; racksInQuorum = new HashSet&lt;String&gt;();</span>
        BookieSocketAddress bookie;
<span class="nc bnc" id="L1016" title="All 2 branches missed.">        for (int i = 0; i &lt; ensembleList.size(); i++) {</span>
<span class="nc" id="L1017">            racksInQuorum.clear();</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            for (int j = 0; j &lt; writeQuorumSize; j++) {</span>
<span class="nc" id="L1019">                bookie = ensembleList.get((i + j) % ensembleSize);</span>
                try {
<span class="nc" id="L1021">                    racksInQuorum.add(knownBookies.get(bookie).getNetworkLocation());</span>
<span class="nc" id="L1022">                } catch (Exception e) {</span>
                    /*
                     * any issue/exception in analyzing whether ensemble is
                     * strictly adhering to placement policy should be
                     * swallowed.
                     */
<span class="nc" id="L1028">                    LOG.warn(&quot;Received exception while trying to get network location of bookie: {}&quot;, bookie, e);</span>
<span class="nc" id="L1029">                }</span>
            }
<span class="nc bnc" id="L1031" title="All 4 branches missed.">            if ((racksInQuorum.size() &lt; minNumRacksPerWriteQuorumForThisEnsemble)</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">                    || (enforceMinNumRacksPerWriteQuorum &amp;&amp; racksInQuorum.contains(getDefaultRack()))) {</span>
<span class="nc" id="L1033">                return PlacementPolicyAdherence.FAIL;</span>
            }
        }
<span class="nc" id="L1036">        return PlacementPolicyAdherence.MEETS_STRICT;</span>
    }

    @Override
    public boolean areAckedBookiesAdheringToPlacementPolicy(Set&lt;BookieSocketAddress&gt; ackedBookies,
                                                            int writeQuorumSize,
                                                            int ackQuorumSize) {
<span class="nc" id="L1043">        HashSet&lt;String&gt; rackCounter = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1044">        int minWriteQuorumNumRacksPerWriteQuorum = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>

<span class="nc" id="L1046">        ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();</span>
<span class="nc" id="L1047">        readLock.lock();</span>
        try {
<span class="nc bnc" id="L1049" title="All 2 branches missed.">            for (BookieSocketAddress bookie : ackedBookies) {</span>
<span class="nc" id="L1050">                rackCounter.add(knownBookies.get(bookie).getNetworkLocation());</span>
<span class="nc" id="L1051">            }</span>

            // Check to make sure that ensemble is writing to `minNumberOfRacks`'s number of racks at least.
<span class="nc bnc" id="L1054" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1055">                LOG.debug(&quot;areAckedBookiesAdheringToPlacementPolicy returning {} because number of racks = {} and &quot;</span>
                          + &quot;minNumRacksPerWriteQuorum = {}&quot;,
<span class="nc bnc" id="L1057" title="All 2 branches missed.">                          rackCounter.size() &gt;= minNumRacksPerWriteQuorum,</span>
<span class="nc" id="L1058">                          rackCounter.size(),</span>
<span class="nc" id="L1059">                          minNumRacksPerWriteQuorum);</span>
            }
        } finally {
<span class="nc" id="L1062">            readLock.unlock();</span>
        }
<span class="nc bnc" id="L1064" title="All 2 branches missed.">        return rackCounter.size() &gt;= minWriteQuorumNumRacksPerWriteQuorum;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>